const e=fetch,t={},s=async(s,r)=>{let n;if(r||(r={}),r.hasOwnProperty("signal"))throw new Error("FetchInterceptor can't receive an abort signal. Please provide the AbortController instance as the 'controller' property instead.");r.hasOwnProperty("controller")?(n=r.controller,delete r.controller):n=new AbortController,r.signal=n.signal;const a=new Request(s,r);for(const[e,s]of Object.entries(t))a.headers.set(e,s);for(const e of o.onBeforeRequest)await e(a,n);const c=e(a);for(const e of o.onAfterRequest)await e(a,n);let i,l,u;try{if(i=await c,i.ok)for(const e of o.onRequestSuccess)await e(i,a,n);else for(const e of o.onRequestFailure)await e(i,a,n)}catch(e){for(const t of o.onRequestException)await t(e,a,n);l=!0,u=e}finally{for(const e of o.onRequestFinally)await e(a,n)}if(l)throw u;return i};let o={onBeforeRequest:[],onAfterRequest:[],onRequestSuccess:[],onRequestFailure:[],onRequestException:[],onRequestFinally:[]},r=!1;export default class n{constructor(){throw new Error("Can not instantiate. Please use the static members.")}static get defaultHeaders(){return t}static set defaultHeaders(e){for(const e of Object.keys(t))delete t[e];for(const[s,o]of Object.entries(e))t[s]=o}static getDefaultHeader(e){return t[e]}static setDefaultHeader(e,s){t[e]=s}static clearDefaultHeader(e){delete t[e]}static addOnBeforeRequest(e){o.onBeforeRequest.push(e)}static addOnAfterRequest(e){o.onAfterRequest.push(e)}static addOnRequestSuccess(e){o.onRequestSuccess.push(e)}static addOnRequestFailure(e){o.onRequestFailure.push(e)}static addOnRequestException(e){o.onRequestException.push(e)}static addOnRequestFinally(e){o.onRequestFinally.push(e)}static clearInterceptors(){for(const e in o)o[e].length=0}static register(){if(r)throw new Error("Already registered!");r=!0,globalThis.fetch=s}static unregister(){if(!r)throw new Error("Not registered!");r=!1,globalThis.fetch=e}}