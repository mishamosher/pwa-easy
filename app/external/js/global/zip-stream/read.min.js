(()=>{const t=(()=>{let t,e,r;const i=[];for(t=0;t<256;t++){for(r=t,e=0;e<8;e++)r=1&r?r>>>1^3988292384:r>>>1;i[t]=r}return i})();class e{constructor(){this.crc=-1}append(e){let r=0|this.crc;for(let i=0,n=0|e.length;i<n;i++)r=r>>>8^t[255&(r^e[i])];this.crc=r}get(){return(-1^this.crc)>>>0}}const r=pako.Inflate,i=globalThis.BigInt||globalThis.Number,n="File format is not recognized.",a=4294967295,s=new TextDecoder,o=(t,e)=>t[e]|t[e+1]<<8;class h{constructor(t,e){if(1347092738!==t.getUint32(0))throw new Error("ERR_BAD_FORMAT");const r=t;this.dataView=r,this._fileLike=e,this._extraFields={};for(let t=46+this.filenameLength;t<r.byteLength;){const e=r.getUint16(t,!0),i=r.getUint16(t+2,!0),n=r.byteOffset+t+4;this._extraFields[e]=new DataView(r.buffer.slice(n,n+i)),t+=i+4}}get versionMadeBy(){return this.dataView.getUint16(4,!0)}get versionNeeded(){return this.dataView.getUint16(6,!0)}get bitFlag(){return this.dataView.getUint16(8,!0)}get encrypted(){return 1==(1&this.bitFlag)}get compressionMethod(){return this.dataView.getUint16(10,!0)}get crc32(){return this.dataView.getUint32(16,!0)}get compressedSize(){return this.dataView.getUint32(20,!0)}get filenameLength(){return this.dataView.getUint16(28,!0)}get extraFieldLength(){return this.dataView.getUint16(30,!0)}get commentLength(){return this.dataView.getUint16(32,!0)}get diskNumberStart(){return this.dataView.getUint16(34,!0)}get internalFileAttributes(){return this.dataView.getUint16(36,!0)}get externalFileAttributes(){return this.dataView.getUint32(38,!0)}get directory(){return!!(16&this.dataView.getUint8(38))}get offset(){return this.dataView.getUint32(42,!0)}get zip64(){return this.dataView.getUint32(24,!0)===a}get comment(){const t=this.dataView,e=new Uint8Array(t.buffer,t.byteOffset+this.filenameLength+this.extraFieldLength+46,this.commentLength);return s.decode(e)}get lastModifiedDate(){const t=this.dataView.getUint32(12,!0);return new Date(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1)}get lastModified(){return+this.lastModifiedDate}get name(){if(!this.bitFlag&&this._extraFields&&this._extraFields[28789])return s.decode(this._extraFields[28789].buffer.slice(5));const t=this.dataView,e=new Uint8Array(t.buffer,t.byteOffset+46,this.filenameLength);return s.decode(e)}get size(){const t=this.dataView.getUint32(24,!0);return t===a?this._extraFields[1].getUint8(0):t}stream(){const t=this,i=new e;let n;const a=e=>{if(n&&n.err)throw new Error(n.msg);i.get()===t.crc32?e.close():e.error(new Error("The crc32 checksum don't match"))};return new ReadableStream({async start(e){const s=await t._fileLike.slice(t.offset+26,t.offset+30).arrayBuffer(),h=new Uint8Array(s),c=o(h,0)+o(h,2)+30,l=t.offset+c,w=l+t.compressedSize;this.reader=t._fileLike.slice(l,w).stream().getReader(),t.compressionMethod&&(n=new r({raw:!0}),n.onData=t=>{i.append(t),e.enqueue(t)},n.onEnd=()=>{a(e)})},async pull(t){const e=await this.reader.read();n?e.done?n.push([],!0):n.push(e.value,!1):e.done?a(t):(i.append(e.value),t.enqueue(e.value))}})}async arrayBuffer(){try{return await new Response(this.stream()).arrayBuffer()}catch(t){throw new Error(`Failed to read Entry\n${t}`)}}async text(){try{return await new Response(this.stream()).text()}catch(t){throw new Error(`Failed to read Entry\n${t}`)}}async blob(){try{return await new Response(this.stream()).blob()}catch(t){throw new Error(`Failed to read Entry\n${t}`)}}async file(){try{return new File([await this.blob()],this.name,{lastModified:this.lastModified})}catch(t){throw new Error(`Failed to read Entry\n${t}`)}}}function c(t,e,r=!1){if("getBigInt64"in DataView.prototype)return t.getBigInt64(e,r);let n=i(0);const a=(128&t.getUint8(e+(r?7:0)))>0;let s=!0;for(let o=0;o<8;o++){let h=t.getUint8(e+(r?o:7-o));a&&(s?0!=h&&(h=255&~(h-1),s=!1):h=255&~h),n+=i(h)*256**i(o)}return a&&(n=-n),n}globalThis.ZipBlobReader=async function*(t){if(t.size<22)throw new Error(n);async function e(e){const r=await t.slice(t.size-e).arrayBuffer(),i=new Uint8Array(r);for(let t=i.length-22;t>=0;t--)if(80===i[t]&&75===i[t+1]&&5===i[t+2]&&6===i[t+3])return new DataView(i.buffer,t,22);return null}let r=await e(22)||await e(Math.min(65558,t.size));if(!r)throw new Error(n);let i=r.getUint16(8,!0),s=r.getUint32(12,!0),l=r.getUint32(16,!0);if(l===a){const e=-r.byteLength-20;r=new DataView(await t.slice(e,-r.byteLength).arrayBuffer());const n=Number(c(r,8,!0)),a=t.slice(n,e);r=new DataView(await a.arrayBuffer()),i=Number(c(r,32,!0)),s=Number(c(r,40,!0)),l=Number(c(r,48,!0))}if(l<0||l>=t.size)throw new Error(n);const w=l,d=l+s,g=t.slice(w,d),f=new Uint8Array(await g.arrayBuffer());for(let e=0,r=0;e<i;e++){const e=o(f,r+28)+o(f,r+30)+o(f,r+32)+46;if(r+e>f.length)throw new Error("Invalid ZIP file.");yield new h(new DataView(f.buffer,r,e),t),r+=e}}})();