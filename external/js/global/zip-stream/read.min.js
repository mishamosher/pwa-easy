const _crc32Table=(()=>{let a,b,c;const d=[];for(a=0;256>a;a++){for(c=a,b=0;8>b;b++)c=1&c?3988292384^c>>>1:c>>>1;d[a]=c}return d})();class Crc32{constructor(){this.crc=-1}append(a){let b=0|this.crc;for(let c=0,d=0|a.length;c<d;c++)b=b>>>8^_crc32Table[255&(b^a[c])];this.crc=b}get(){return(-1^this.crc)>>>0}}const Inflate=pako.Inflate,BigInt=globalThis.BigInt||globalThis.Number,ERR_BAD_FORMAT="File format is not recognized.",ZIP_COMMENT_MAX=65536,EOCDR_MIN=22,EOCDR_MAX=EOCDR_MIN+ZIP_COMMENT_MAX,MAX_VALUE_32BITS=4294967295,decoder=new TextDecoder,uint16e=(a,b)=>a[b]|a[b+1]<<8;class Entry{constructor(a,b){if(1347092738!==a.getUint32(0))throw new Error("ERR_BAD_FORMAT");const c=a;this.dataView=c,this._fileLike=b,this._extraFields={};for(let d=46+this.filenameLength;d<c.byteLength;){const a=c.getUint16(d,!0),b=c.getUint16(d+2,!0),e=c.byteOffset+d+4;this._extraFields[a]=new DataView(c.buffer.slice(e,e+b)),d+=b+4}}get versionMadeBy(){return this.dataView.getUint16(4,!0)}get versionNeeded(){return this.dataView.getUint16(6,!0)}get bitFlag(){return this.dataView.getUint16(8,!0)}get encrypted(){return 1==(1&this.bitFlag)}get compressionMethod(){return this.dataView.getUint16(10,!0)}get crc32(){return this.dataView.getUint32(16,!0)}get compressedSize(){return this.dataView.getUint32(20,!0)}get filenameLength(){return this.dataView.getUint16(28,!0)}get extraFieldLength(){return this.dataView.getUint16(30,!0)}get commentLength(){return this.dataView.getUint16(32,!0)}get diskNumberStart(){return this.dataView.getUint16(34,!0)}get internalFileAttributes(){return this.dataView.getUint16(36,!0)}get externalFileAttributes(){return this.dataView.getUint32(38,!0)}get directory(){return!!(16&this.dataView.getUint8(38))}get offset(){return this.dataView.getUint32(42,!0)}get zip64(){return this.dataView.getUint32(24,!0)===MAX_VALUE_32BITS}get comment(){const a=this.dataView,b=new Uint8Array(a.buffer,a.byteOffset+this.filenameLength+this.extraFieldLength+46,this.commentLength);return decoder.decode(b)}get lastModifiedDate(){const a=this.dataView.getUint32(12,!0);return new Date((127&a>>25)+1980,(15&a>>21)-1,31&a>>16,31&a>>11,63&a>>5,(31&a)<<1)}get lastModified(){return+this.lastModifiedDate}get name(){if(!this.bitFlag&&this._extraFields&&this._extraFields[28789])return decoder.decode(this._extraFields[28789].buffer.slice(5));const a=this.dataView,b=new Uint8Array(a.buffer,a.byteOffset+46,this.filenameLength);return decoder.decode(b)}get size(){const a=this.dataView.getUint32(24,!0);return a===MAX_VALUE_32BITS?this._extraFields[1].getUint8(0):a}stream(){const a=this,b=new Crc32;let c;const d=d=>{if(c&&c.err)throw new Error(c.msg);b.get()===a.crc32?d.close():d.error(new Error("The crc32 checksum don't match"))};return new ReadableStream({async start(e){const f=await a._fileLike.slice(a.offset+26,a.offset+30).arrayBuffer(),g=new Uint8Array(f),h=uint16e(g,0)+uint16e(g,2)+30,i=a.offset+h,j=i+a.compressedSize;this.reader=a._fileLike.slice(i,j).stream().getReader(),a.compressionMethod&&(c=new Inflate({raw:!0}),c.onData=a=>{b.append(a),e.enqueue(a)},c.onEnd=()=>{d(e)})},async pull(a){const e=await this.reader.read();c?e.done?c.push([],!0):c.push(e.value,!1):e.done?d(a):(b.append(e.value),a.enqueue(e.value))}})}async arrayBuffer(){try{return await new Response(this.stream()).arrayBuffer()}catch(a){throw new Error(`Failed to read Entry\n${a}`)}}async text(){try{return await new Response(this.stream()).text()}catch(a){throw new Error(`Failed to read Entry\n${a}`)}}async blob(){try{return await new Response(this.stream()).blob()}catch(a){throw new Error(`Failed to read Entry\n${a}`)}}async file(){try{return new File([await this.blob()],this.name,{lastModified:this.lastModified})}catch(a){throw new Error(`Failed to read Entry\n${a}`)}}}function getBigInt64(a,b,c=!1){if("getBigInt64"in DataView.prototype)return a.getBigInt64(b,c);let d=BigInt(0);const e=0<(128&a.getUint8(b+(c?7:0)));let f=!0;for(let g,h=0;8>h;h++)g=a.getUint8(b+(c?h:7-h)),e&&(f?0!=g&&(g=255&~(g-1),f=!1):g=255&~g),d+=BigInt(g)*256**BigInt(h);return e&&(d=-d),d}async function*Reader(a){async function b(b){const c=await a.slice(a.size-b).arrayBuffer(),d=new Uint8Array(c);for(let a=d.length-EOCDR_MIN;0<=a;a--)if(80===d[a]&&75===d[a+1]&&5===d[a+2]&&6===d[a+3])return new DataView(d.buffer,a,EOCDR_MIN);return null}if(a.size<EOCDR_MIN)throw new Error(ERR_BAD_FORMAT);let c=(await b(EOCDR_MIN))||(await b(Math.min(EOCDR_MAX,a.size)));if(!c)throw new Error(ERR_BAD_FORMAT);let d=c.getUint16(8,!0),e=c.getUint32(12,!0),f=c.getUint32(16,!0);const g=f===MAX_VALUE_32BITS;if(g){const b=-c.byteLength-20;c=new DataView(await a.slice(b,-c.byteLength).arrayBuffer());const g=+getBigInt64(c,8,!0),h=a.slice(g,b);c=new DataView(await h.arrayBuffer()),d=+getBigInt64(c,32,!0),e=+getBigInt64(c,40,!0),f=+getBigInt64(c,48,!0)}if(0>f||f>=a.size)throw new Error(ERR_BAD_FORMAT);const h=f,i=f+e,j=a.slice(h,i),k=new Uint8Array(await j.arrayBuffer());for(let b=0,c=0;b<d;b++){const b=uint16e(k,c+28)+uint16e(k,c+30)+uint16e(k,c+32)+46;if(c+b>k.length)throw new Error("Invalid ZIP file.");yield new Entry(new DataView(k.buffer,c,b),a),c+=b}}globalThis.ZipBlobReader=Reader;